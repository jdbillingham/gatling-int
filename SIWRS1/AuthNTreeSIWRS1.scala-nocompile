/*
* OpenAM AuthN tree simulation.
*
* Copyright (c) 2018 ForgeRock AS. Use of this source code is subject to the
* Common Development and Distribution License (CDDL) that can be found in the LICENSE file
*/

package openam

import io.gatling.core.Predef._
import io.gatling.core.scenario.Simulation
import io.gatling.core.structure.ScenarioBuilder
import io.gatling.http.protocol.HttpProtocolBuilder
import scala.collection.mutable
import io.gatling.core.structure.ChainBuilder
import io.gatling.core.body.StringBody
import io.gatling.core.session
import io.gatling.http.check.HttpCheck
import io.gatling.http.request.builder.HttpRequestBuilder

class AuthNTreeSIWRS1 extends Simulation {

  val userPoolSize: Integer = Integer.getInteger("users", 10000000)
  val concurrency: Integer = Integer.getInteger("concurrency", 800)
  val duration: Integer = Integer.getInteger("duration", 600)
  val warmup: Integer = Integer.getInteger("warmup", 0)
  val amHost: String = System.getProperty("am_host", "login.test.kubernetes.org.uk")
  val amPort: String = System.getProperty("am_port", "443")
  val amProtocol: String = System.getProperty("am_protocol", "https")
  val resource_version = System.getProperty("resource_version", "2.0")

  val realm: String = System.getProperty("realm", "/")
  val service_name = System.getProperty("service_name", "SIWRS1")
  val root_url = System.getProperty("root_url", "")

  val amUrl: String = amProtocol + "://" + amHost + ":" + amPort
  val random = new util.Random

  val userFeeder: Iterator[Map[String, String]] = Iterator.continually(Map(
      """username""" -> ("""user.""" + random.nextInt(userPoolSize).toString),
      """password""" -> "password")
  )

  def getXOpenAMHeaders(username: String, password: String): scala.collection.immutable.Map[String, String] = {
      scala.collection.immutable.Map(
          "X-OpenAM-Username" -> username,
          "X-OpenAM-Password" -> password)
  }
  def getAcceptAPIVersion(resource_version: String = resource_version): scala.collection.immutable.Map[String, String] = {
    val value = "protocol=1.0,resource=" + resource_version
    scala.collection.immutable.Map(
      "Accept-API-Version" -> value
    )
  }

  // default header value
  val acceptAPIVersion = getAcceptAPIVersion()

  def realm2url(realm: String): String = {
    var realm2url = realm
    if (!realm2url.startsWith("/"))
      realm2url = "/" + realm2url
    if (!realm2url.endsWith("/"))
      realm2url += "/"
    realm2url
  }

  /**
    *
    * @param category end point category (i.e. users, authenticate, policies...)
    * @param realm    the realm of the url
    * @param root_url (optional) root_url to be added as a prefix to the url
    * @return the url of the REST endpoint
    */
  def getJsonURL(category: String, resourceName: String = "", realm: String = "/",
                 resource_version: String = resource_version, root_url: String = ""): String = {
    var url = root_url
    var _resourceName = resourceName
    if (resource_version < "2.0") {
      url += "/openam/json%s%s".format(realm2url(realm), category)
    } else {
      url += "/openam/json/%s".format(category)
      if (category == "sessions") {
        _resourceName = ""
      }
    }
    if (_resourceName != "") {
      url += "/" + _resourceName
    }
    url
  }

  /**
    * Set query map for authN Tree
    */
  val url = getJsonURL(category = "authenticate", realm = realm, root_url = root_url)
  val queryParamMap: mutable.Map[String, Any] = mutable.Map[String, Any]()
  queryParamMap.put("authIndexType", "service")
  queryParamMap.put("authIndexValue", service_name)
  if (realm != "/") {
    queryParamMap.put("realm", realm)
  }

  /**
    * Define scenario
    */
  val authNTreeScenario: ScenarioBuilder = scenario("AuthN Tree Flow SIWRS1")
          .during(duration) {
              feed(userFeeder)
              .exec(flushCookieJar)
              .exec(restLoginInitiate(queryParamMap, url))
              .pause(1)
              .exec(restLoginUsernameCallback(authId = "${authId}", "${username}", queryParamMap, url))
              .pause(1)
              .exec(restLoginPasswordCallback(authId = "${authId}", "${password}", queryParamMap, url))
          }

      setUp(accessTokenScenario.inject(rampUsers(concurrency) over warmup)).protocols(httpProtocol)

  /**
    * Makes a single POST to the authentication endpoint, initiating but not progressing the authentication flow
    *
    * @param queryParamMap         the query parameters to be added to the POST
    * @param url                   the url to submit the POST to
    * @param requestName           the name of the request to be used in the report (default: RestLogin)
    * @return chainBuilder         instance to be executed in the scenario
    */
  def restLoginInitiate(queryParamMap: mutable.Map[String, Any], url: String, requestName: String = "restLoginInitiate"): ChainBuilder = {

    exec(
      http(requestName)
        .post(url)
        .queryParamMap(queryParamMap.toMap)
        .asJson
        .body(StringBody(""))
        .headers(acceptAPIVersion)
        .check(status.is(200))
        .check(jsonPath("$.authId").find.saveAs("authId"))
    )
  }

  /**
    * Makes a single POST to the authentication endpoint, providing the username of the authenticating user
    *
    * @param authId                the authID of this authentication session
    * @param username              the username used for authentication
    * @param queryParamMap         the query parameters to be added to the POST
    * @param url                   the url to submit the POST to
    * @param requestName           the name of the request to be used in the report (default: RestLogin)
    * @return chainBuilder         instance to be executed in the scenario
    */
  def restLoginUsernameCallback(authId: String, username: String, queryParamMap: mutable.Map[String, Any], url: String,
                                requestName: String = "restLoginUsernameCallback"): ChainBuilder = {

    exec(http(requestName)
      .post(url)
      .queryParamMap(queryParamMap.toMap)
      .headers(acceptAPIVersion)
      .asJson
      .body(StringBody(
        """{"authId":"%s",""".format(authId) +
          """"callbacks":[{"type":"NameCallback","output":[{"name":"prompt","value":"User Name:"}],""" +
          """"input":[{"name":"IDToken1","value":"%s"}]}]}""".format(username)
      ))
      .check(status.is(200))
      .check(jsonPath("$.authId").find.saveAs("authId"))
    )
  }

  /**
    * Makes a single POST to the authentication endpoint, providing the password of the authenticating user
    *
    * @param authId                the authID of this authentication session
    * @param password              the password used for authentication
    * @param queryParamMap         the query parameters to be added to the POST
    * @param url                   the url to submit the POST to
    * @param requestName           the name of the request to be used in the report (default: RestLogin)
    * @return chainBuilder instance to be executed in the scenario
    */
  def restLoginPasswordCallback(authId: String, password: String, queryParamMap: mutable.Map[String, Any], url: String,
                                requestName: String = "restLoginPasswordCallback"): ChainBuilder = {

    exec(http(requestName)
      .post(url)
      .queryParamMap(queryParamMap.toMap)
      .headers(acceptAPIVersion)
      .asJson
      .body(StringBody(
        """{"authId":"%s",""".format(authId) +
          """"callbacks":[{"type":"PasswordCallback",""" +
          """"output":[{"name":"prompt","value":"Password:"}],"input":[{"name":"IDToken2","value":"%s"}]}]}""".format(password)
      ))
      .check(status.is(200))
      .check(jsonPath("$.tokenId").find.saveAs("tokenId"))
    )
      .exec(addCookie(Cookie("iPlanetDirectoryPro", "${tokenId}")))
  }

}
